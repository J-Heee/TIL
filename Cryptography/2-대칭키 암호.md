# Chapter 2. 대칭키 암호

## 2020.09.29

### 2-0. 대칭키 암호(Symmetric cryptography)
- 암호 시스템 : A가 평문과 키를 이용해서 암호문을 생성하고, B가 암호문과 키를 이용해서 다시 평문을 얻어보는 시스템
- 이때, **암호화와 복호화에 사용하는 키가 동일한 경우**를 대칭키 암호 시스템이라고 함
- 메시지를 주고 받는 두 사용자(A와 B)가 서로 동일한 키를 사전에 안전하게 둘만 공유한 상태로 가정
- 많은 고전암호(스키테일 암호, 시저 암호, 단일/다중 치환암호, One-time pad 등)는 대칭키 암호의 일종


### 2-1. 스트림 암호
- 데이터의 흐름(스트림)을 순차적으로 처리해가는 대칭키 암호 알고리즘
- 스트림 암호는 블록 암호만큼 일반적으로 사용되지는 않음
  - 블록 암호에 비해서 안전성은 떨어지지만, 처리 속도는 빠른 편이므로 실시간으로 스트리밍 되는 콘텐츠(음원, 영상 등)를 암호화하는데 주로 사용
  - 무선통신과 같은 환경에서도 여전히 사용되는 중
- **평문과 동일한 길이의 키스트림, 즉 비트스트링을 생성해서 평문과 XOR연산**을 함으로써 암호화와 복호화 수행
  - 암호화: 평문과 키스트림 XOR
  - 복호화: 암호문과 키스트림 XOR
  - 이 부분은 One-time pad 암호와 비슷함 
- **키 𝐾 (n-bit)가 긴 길이의 키스트림(keystream)으로 확장됨**
  - 평문보다 짧은 길이의 키를 이용해서, 평문 정도 길이의 키스트림으로 확장하는 기술 사용
  - 비교적 짧은 길이의 키만 알고 있어도 된다는 장점
  - 평문의 길이와 동일한 크기의 키를 외워야하는 불편함이 있었던 One-time pad 암호와의 차이점
- 확장된 키스트림은 one-time pad로 사용됨
  - 𝑐0 = 𝑝0 ⊕ 𝑠0, 𝑐1 = 𝑝1 ⊕ 𝑠1, 𝑐2 = 𝑝2 ⊕ 𝑠2, …
- 대표적인 두 가지 알고리즘 
  - **A5/1** : GSM(유럽식 디지털 이동 통신 방식) 휴대폰에 사용 (H/W 기반)
  - **RC4** : SSL(인터넷 트래픽 보호) 프로토콜에 사용 (S/W 기반)



#### A5/1
- 3개의 **시프트 레지스터(Shift register)** 로 구성
- Linear feedback shift register (LFSR)
  - initial state에서 레지스터의 정해진 연산(ex. 3,5,8번째 비트를 XOR연산)을 수행하여 나온 결과값은 feedback input으로 레지스터의 가장 왼쪽 비트에 입력으로 들어감. 새로운 값이 입력되면 자동으로 나머지 값들이 오른쪽으로 한 칸씩 시프트 되어 가장 오른쪽 비트에 있던 값은 output으로 나오게 됨.
  - 이렇게 한 번의 연산으로 첫 번째 output을 얻고, 그 상태의 레지스터에서 output의 두 번째 비트를 출력하기 위해서 다시 정해진 연산 수행
  - 순서대로 반복하여 output 비트 생성


- **A5/1에서 사용하는 키 𝐾는 64비트이고, 처음에 X, Y, Z 레지스터의 초기값을 채울 때 사용**
  - X: 19 bits (x0, x1, x2, …, x18)
  - Y: 22 bits (y0, y1, y2, ………, y21)
  - Z: 23 bits (z0, z1, z2, …………., z22)
  - X+Y+Z = 64 bits

- 𝑚 = maj (𝑥8, 𝑦10, 𝑧10) // 𝑥8, 𝑦10, 𝑧10 중 많은 수를 선택하여 하나의 bit를 output으로 반환
  - If 𝑥8 == 𝑚,
  - Then 𝑥0 = 𝑥13 ⊕ 𝑥16 ⊕ 𝑥17 ⊕ 𝑥18
  - 1-bit right shift (𝑥18 = 𝑥17, 𝑥17 = 𝑥16, … , 𝑥1 = 𝑥0)
  - If 𝑦10 == 𝑚,
  - Then 𝑦0 = 𝑦20 ⊕ 𝑦21
  - 1-bit right shift
  - If 𝑧10 == 𝑚,
  - Then 𝑧0 = 𝑧7 ⊕ 𝑧20 ⊕ 𝑧21 ⊕ 𝑧22
  - 1-bit right shift
  - majority함수의 ouput과 같은 값이 아닐 경우는 어떠한 연산도 수행하지 않음

- Keystream bit 𝑠 = 𝑥18 ⊕ 𝑦21 ⊕ 𝑧22
  - X,Y,Z 모두 한 번의 연산을 수행하면 레지스터에는 초기값이 아닌 새로운 값으로 채워짐
  - 그 새로운 상태의 레지스터에서 가장 오른쪽에 있는 값들(𝑥18, 𝑦21, 𝑧22)을 XOR한 값이 키스트림의 첫번째 비트가 됨
  - 이런식으로 반복적으로 동작하다보면 1비트씩 키스트림을 계속 생성하게 되는데, 만약 평문이 228-bit라면 키스트림이 228-bit가 될 때까지 228번 연산을 반복해주어야 함


#### RC4
- RC4는 A5/1에 비해 훨씬 더 심플한 구조
  - **변경되는 룩업 테이블(lookup table)** 을 기반으로 구성
  - 룩업테이블을 하나 만들어놓고, 그 값들을 업데이트 시켜가면서 키스트림을 생성하는 구조
1. 키를 이용하여 룩업 테이블 초기화
2. 각 단계에서
   - 현재 룩업 테이블 요소들을 변경 (RC4 알고리즘)
   - 테이블에서 키스트림 바이트를 선택
- A5/1은 한번에 single keystream **bit**를 생성하는 반면, **RC4는 keystream byte를 생성**함
  - A5/1은 평문 1bit와 키스트림 1bit를 XOR해서 암호문 1bit를 생성
  - RC4는 평문 1byte와 키스트림 1byte를 XOR해서 암호문 1byte를 생성

- 키를 이용한 룩업 테이블(256 바이트 순열) 초기화
  - 키 크기는 0~256 사이의 임의의 바이트
  - 키가 N bytes 일 때 어떤식으로 룩업테이블 S를 초기화하는지를 나타낸 수식
```
key[] contains N bytes of key

for i = 0 to 255
    S[i] = i
    K[i] = key[i (mod N)]
j = 0
for i = 0 to 255
    j = (j + S[i] + K[i]) mod 256
    swap(S[i], S[j])
```

- 1-byte 키스트림 생성
  - 룩업테이블 S를 초기화 후, S를 가지고 키스트림을 어떻게 생성하는지
  - 1 byte의 키스트림을 생성할때마다 룩업테이블이 조금씩 변화함
```
i = 0, j = 0

i := (i + 1) mod 256      //i,j 업데이트
j := (j + S[i]) mod 256
swap(S[i], S[j])
t = (S[i] + S[j]) mod 256

keystreambyte = S[t]
```
- One-time pad로 키스트림 바이트 사용하여 암호화
- 최초 256 바이트는 폐기해야 함
  - 그렇지 않으면 공격자가 키 복구 가능!