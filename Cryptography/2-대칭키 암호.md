# Chapter 2. 대칭키 암호

## 2020.09.29

### 2-0. 대칭키 암호(Symmetric cryptography)
- 암호 시스템 : A가 평문과 키를 이용해서 암호문을 생성하고, B가 암호문과 키를 이용해서 다시 평문을 얻어보는 시스템
- 이때, **암호화와 복호화에 사용하는 키가 동일한 경우**를 대칭키 암호 시스템이라고 함
- 메시지를 주고 받는 두 사용자(A와 B)가 서로 동일한 키를 사전에 안전하게 둘만 공유한 상태로 가정
- 많은 고전암호(스키테일 암호, 시저 암호, 단일/다중 치환암호, One-time pad 등)는 대칭키 암호의 일종


### 2-1. 스트림 암호
- 데이터의 흐름(스트림)을 순차적으로 처리해가는 대칭키 암호 알고리즘
- 스트림 암호는 블록 암호만큼 일반적으로 사용되지는 않음
  - 블록 암호에 비해서 안전성은 떨어지지만, 처리 속도는 빠른 편이므로 실시간으로 스트리밍 되는 콘텐츠(음원, 영상 등)를 암호화하는데 주로 사용
  - 무선통신과 같은 환경에서도 여전히 사용되는 중
- **평문과 동일한 길이의 키스트림, 즉 비트스트링을 생성해서 평문과 XOR연산**을 함으로써 암호화와 복호화 수행
  - 암호화: 평문과 키스트림 XOR
  - 복호화: 암호문과 키스트림 XOR
  - 이 부분은 One-time pad 암호와 비슷함 
- **키 𝐾 (n-bit)가 긴 길이의 키스트림(keystream)으로 확장됨**
  - 평문보다 짧은 길이의 키를 이용해서, 평문 정도 길이의 키스트림으로 확장하는 기술 사용
  - 비교적 짧은 길이의 키만 알고 있어도 된다는 장점
  - 평문의 길이와 동일한 크기의 키를 외워야하는 불편함이 있었던 One-time pad 암호와의 차이점
- 확장된 키스트림은 one-time pad로 사용됨
  - 𝑐0 = 𝑝0 ⊕ 𝑠0, 𝑐1 = 𝑝1 ⊕ 𝑠1, 𝑐2 = 𝑝2 ⊕ 𝑠2, …
- 대표적인 두 가지 알고리즘 
  - **A5/1** : GSM(유럽식 디지털 이동 통신 방식) 휴대폰에 사용 (H/W 기반)
  - **RC4** : SSL(인터넷 트래픽 보호) 프로토콜에 사용 (S/W 기반)



#### A5/1
- 3개의 **시프트 레지스터(Shift register)** 로 구성
- Linear feedback shift register (LFSR)
  - initial state에서 레지스터의 정해진 연산(ex. 3,5,8번째 비트를 XOR연산)을 수행하여 나온 결과값은 feedback input으로 레지스터의 가장 왼쪽 비트에 입력으로 들어감. 새로운 값이 입력되면 자동으로 나머지 값들이 오른쪽으로 한 칸씩 시프트 되어 가장 오른쪽 비트에 있던 값은 output으로 나오게 됨.
  - 이렇게 한 번의 연산으로 첫 번째 output을 얻고, 그 상태의 레지스터에서 output의 두 번째 비트를 출력하기 위해서 다시 정해진 연산 수행
  - 순서대로 반복하여 output 비트 생성


- **A5/1에서 사용하는 키 𝐾는 64비트이고, 처음에 X, Y, Z 레지스터의 초기값을 채울 때 사용**
  - X: 19 bits (x0, x1, x2, …, x18)
  - Y: 22 bits (y0, y1, y2, ………, y21)
  - Z: 23 bits (z0, z1, z2, …………., z22)
  - X+Y+Z = 64 bits

- 𝑚 = maj (𝑥8, 𝑦10, 𝑧10) // 𝑥8, 𝑦10, 𝑧10 중 많은 수를 선택하여 하나의 bit를 output으로 반환
  - If 𝑥8 == 𝑚,
  - Then 𝑥0 = 𝑥13 ⊕ 𝑥16 ⊕ 𝑥17 ⊕ 𝑥18
  - 1-bit right shift (𝑥18 = 𝑥17, 𝑥17 = 𝑥16, … , 𝑥1 = 𝑥0)
  - If 𝑦10 == 𝑚,
  - Then 𝑦0 = 𝑦20 ⊕ 𝑦21
  - 1-bit right shift
  - If 𝑧10 == 𝑚,
  - Then 𝑧0 = 𝑧7 ⊕ 𝑧20 ⊕ 𝑧21 ⊕ 𝑧22
  - 1-bit right shift
  - majority함수의 ouput과 같은 값이 아닐 경우는 어떠한 연산도 수행하지 않음

- Keystream bit 𝑠 = 𝑥18 ⊕ 𝑦21 ⊕ 𝑧22
  - X,Y,Z 모두 한 번의 연산을 수행하면 레지스터에는 초기값이 아닌 새로운 값으로 채워짐
  - 그 새로운 상태의 레지스터에서 가장 오른쪽에 있는 값들(𝑥18, 𝑦21, 𝑧22)을 XOR한 값이 키스트림의 첫번째 비트가 됨
  - 이런식으로 반복적으로 동작하다보면 1비트씩 키스트림을 계속 생성하게 되는데, 만약 평문이 228-bit라면 키스트림이 228-bit가 될 때까지 228번 연산을 반복해주어야 함


#### RC4
- RC4는 A5/1에 비해 훨씬 더 심플한 구조
  - **변경되는 룩업 테이블(lookup table)** 을 기반으로 구성
  - 룩업테이블을 하나 만들어놓고, 그 값들을 업데이트 시켜가면서 키스트림을 생성하는 구조
1. 키를 이용하여 룩업 테이블 초기화
2. 각 단계에서
   - 현재 룩업 테이블 요소들을 변경 (RC4 알고리즘)
   - 테이블에서 키스트림 바이트를 선택
- A5/1은 한번에 single keystream **bit**를 생성하는 반면, **RC4는 keystream byte를 생성**함
  - A5/1은 평문 1bit와 키스트림 1bit를 XOR해서 암호문 1bit를 생성
  - RC4는 평문 1byte와 키스트림 1byte를 XOR해서 암호문 1byte를 생성

- 키를 이용한 룩업 테이블(256 바이트 순열) 초기화
  - 키 크기는 0~256 사이의 임의의 바이트
  - 키가 N bytes 일 때 어떤식으로 룩업테이블 S를 초기화하는지를 나타낸 수식
```
key[] contains N bytes of key

for i = 0 to 255
    S[i] = i
    K[i] = key[i (mod N)]
j = 0
for i = 0 to 255
    j = (j + S[i] + K[i]) mod 256
    swap(S[i], S[j])
```

- 1-byte 키스트림 생성
  - 룩업테이블 S를 초기화 후, S를 가지고 키스트림을 어떻게 생성하는지
  - 1 byte의 키스트림을 생성할때마다 룩업테이블이 조금씩 변화함
```
i = 0, j = 0

i := (i + 1) mod 256      //i,j 업데이트
j := (j + S[i]) mod 256
swap(S[i], S[j])
t = (S[i] + S[j]) mod 256

keystreambyte = S[t]
```
- One-time pad로 키스트림 바이트 사용하여 암호화
- 최초 256 바이트는 폐기해야 함
  - 그렇지 않으면 공격자가 키 복구 가능!


### 2-2. 블록암호

#### 블록 암호의 개념
- 일반적으로 많이 사용하는 대칭키 암호
- 특정 길이의 평문을 블록 단위로 묶어서 한번에 처리하는 대칭키 암호 알고리즘
- 평문과 암호문이 **고정된 크기의 블록**으로 구성
  - 평문을 일정한 크기의 블록으로 나누고, 고정된 크기를 가지는 블록 단위의 암호문을 생성
- 블록암호는 **혼돈(confusion)과 확산(diffusion) 모두가 적용됨**  
  - P-box (permutation box)와 S-box (Substitution box), 그 밖의 구성요소들 (XOR, Shift, Swap 등)을 결합하여 설계
  - 혼돈: S-box와 같은 요소들 사용 (치환)
  - 확산: P-box와 같은 요소들 사용
  - 혼돈과 확산 두 가지를 함께 사용하는 암호를 합성 암호(Product Cipher)라고 부름
  - **여러 라운드(round)를 반복**함으로써 혼돈과 확산을 충분히 만족하도록 해야 함


#### 구성요소
1. **P-box**
- 문자 단위로 수행하였던 고전 전치(transposition) 암호를 **비트 단위로 수행**
- 3종류: 단순(Straight), 축소(Compression), 확장(Expansion)
- Straight P-box : 역함수 존재O, input과 ouput의 비트 크기가 동일, 비트들의 위치 변경
- Compression P-box : 역함수 존재X, input보다 output 비트의 개수가 작음
- Expansion P-box : 역함수 존재X, input보다 output 비트의 개수가 더 많음, 하나의 input이 여러번 output 되는 형태

2. **S-box**
- 대치(substitution) 암호
- 문자 단위로 수행하였던 고전 암호에서의 치환을 비트 단위로 수행
- 입력 비트와 출력 비트의 개수가 달라도 상관없음
- **역함수**가 존재하기 위해서는 입력 비트와 출력 비트의 개수가 같아야 함

3. **라운드(round)**
- 확산과 혼돈은 S-box, P-box, 기타 구성 요소들이 결합된 합성 암호(product cipher)를 반복적으로 사용하여 얻어짐
- 합성 암호가 반복적으로 사용되는 것을 ‘라운드’라 함
- 라운드가 진행될수록 점점 혼돈과 확산의 성질이 커지게 됨
  - 블록암호를 설계할 때, 라운드를 대체 몇 번 반복해야 하는가?
  - 라운드를 반복할수록 안전성은 증가하지만, 연산의 증가로 효율성을 떨어짐
  - 응용 환경에서 요구되는 수준의 안전성을 보장할 수 있는 수준까지만 라운드를 진행하면 됨
  - 블록암호마다 다양한 요소를 고려하여 적절한 라운드 수 결정


#### DES (Data Encryption Standard)
- **56-bit 키**를 사용하여 **64-bit 데이터**를 암호화 함
- 암호문은 64-bit
- 복호화 알고리즘은 암호화 알고리즘과 동일하며, **키만 reverse order로 입력**하면 됨 (Feistel 구조)
- **총 16개의 라운드로 구성**
  - 라운드가 반복되는 합성 암호의 구조를 가져, 혼돈과 확산의 성질을 만족함
  - Initial permutation과 Final permutation이 Straight P-box로 서로 역함수 구조로 되어있음
  - Round-key generator에서 처음에 DES의 56bits 대칭키를 입력받아서 각 라운드별로 48bits의 상이한 라운드키를 생성, 총 16개의 서로 다른 라운드키 생성
  - 하나의 라운드에서는 64bits가 32bits씩 반으로 쪼개서 연산 수행
  - 라운드 내부에는 크게 Mixer와 Swapper 존재
- 1970년대에 개발되어 당시에는 안전한 방법이였으나, 전수조사를 하면 최대 2의56제곱 번의 계산만 필요하여 현대에서는 안전하지 않음 -> 단점 보완을 위해 다중 DES 등장


#### 다중 DES - 이중 DES (Double DES, 2DES)
- DES를 두 번 사용
- DES의 56-bit 짧은 키를 보완하기 위해서 서로 다른 두개의 키를 이용해서 두 번의 DES암호를 사용하는 방식
- 𝐶2 = 𝐸(𝐶1,𝐾2) where 𝐶1 = 𝐸(𝑃,𝐾1) -> 암호문은 𝐶2, 키는 (𝐾1,𝐾2)
  1. 56-bit키 𝐾1을 이용해서 평문𝑃를 암호화해 암호문𝐶1 생성
  2. 또 다른 56-bit키 𝐾2를 이용해서 암호문𝐶1을 다시 한번 암호화해서 최종적으로 암호문𝐶2 생성
- **키가 112-bit** 가 되었으니 전수조사에 대한 안전성도 그만큼 증가했을까? -> 결론은 NO!
  - **“Meet-in-the-Middle” Attack** (중간자 일치 공격 - 알려진 평문 공격의 한 종류)
  - 공격자가 평문과 암호문 쌍을 알고있다고 생각하면, 이중DES에서 평문P를 첫번째 키K1으로 암호화한 값이, 암호문 C를 두번째 키K2로 복호화한 값과 같다는 사실 이용
  - Attacker inputs known 𝑷 and gets 𝑪
  - 𝐸(𝑃,𝐾1) = 𝑀 = 𝐷(𝐶,𝐾2)
  - brute-force: 2 × 2의56제곱 + 𝑂(nlogn) ≈ **2의63제곱** << 2의112제곱


#### 다중 DES - 삼중 DES (Triple DES, 3DES)
- DES를 3번 사용하면 더 안전해질까?
- 키가 168-bit니까 전수조사를 하면 2의168제곱?
- 실제로는 **112-bit 키 사용** (𝐾1과 𝐾2 -> 112-bit, 𝐾3 = 𝐾1)
  - 이유 : MITM 공격을 이용해도 112-bit 안전성 보장 가능하므로 안전성 동일
  - 𝐸(𝑃,𝐾1) = 𝑀 = 𝐸(𝐷(𝐶,𝐾1),𝐾2)  
- 구성도 E을 3번 하지 않고 **E-D-E 순서(암호화-복호화-암호화)로 진행** (복호화는 D-E-D)
  - 이유 : DES와의 호환성 때문
  - If 𝐾1 = 𝐾2 = 𝐾, then 𝐸(𝐷(𝐸(𝑃,𝐾),𝐾),𝐾) = 𝐸(𝑃,𝐾)
- 3DES는 널리 사용되었으나, AES의 등장으로 점점 사라지는 추세


#### AES (Advanced Encryption Standard)
- DES의 키 사이즈(56-bit)는 현재 컴퓨팅 파워에서는 너무 작음, 전수조사에 취약함
- 1990년대에 개발
- DES와 동일하게 **여러 라운드가 반복되는 구조**이지만, (Feistel 구조가 아니기 때문에) **암호화 알고리즘과 복호화 알고리즘이 상이함**
- AES는 128-bit 평문이 들어오면 그것을 4X4 행렬로 변환 (행렬의 하나의 요소는 1byte)
  - 한 블록의 크기는 128-bit  
  - DES는 64-bit input이 들어오면 bit단위로 연산
- 사용할 수 있는 암호화 키의 크기가 128, 192, 256bits의 세가지 종류
  - 키사이즈에 따라 라운드 숫자도 변경
- 안전성을 제공하기 위해 AES는 4가지 종류의 구성요소를 사용함
  - 1 of permutation » ShiftRow
  - 3 substitutions » SubBytes, MixColumns, AddRoundKey
- AES의 모든 구성요소는 invertible함, 역함수가 존재하는 구조
  - 복호화 알고리즘에서는 모든 구성요소들이 inverse 형태로 수행됨
  - Round key는 reverse order로 사용해야 함


### 2-3. 블록암호 운용모드
- 평문은 보통 길이가 길기 때문에, 블록암호를 이용해서 평문을 암호화하는 경우에는 다수의 블록으로 쪼개서 진행
- 블록암호를 실제 환경에서 사용할 때 적용할 수 있는 다양한 운용방식 의미

#### ECB (Electronic CodeBook) 모드
- 가장 단순한 형태로, 각 블록을 독립적으로 암호화
- 평문을 블록으로 쪼개서 각각을 동일한 키를 이용하여 암호화
- 단점
  - 암호문을 통해 평문의 패턴이 그대로 노출됨 (평문이 같으면 암호문도 같기 때문에)
  - **Block replay에 취약**함 (블록이 독립적이기 때문에)
- 장점
  - 에러 전이(error propagation)가 없음
  - 병렬 컴퓨팅(parallel computing)이 가능함


#### CBC (Cipher Block Chaining) 모드
- 블록을 체인처럼 함께 연결하여 암호화
- 이니셜 벡터 (Initialization Vector, IV)를 사용함
- IV는 블록의 크기와 동일한 크기로, 랜덤해야하며, 공개된 정보임
- 장점 (ECB모드의 단점 커버)
  - 암호문을 통해 평문의 패턴이 드러나지 않음 (동일한 평문이더라도 실제로 암호문에 들어가는 값은 달라지기 때문에)
  - Block replay와 같이 복호화 시 원하는 평문이 나오도록 암호문을 조작할 수 없음
- 단점 (ECB모드의 장점이 단점으로)
  - 병렬 컴퓨팅이 불가능함, 효율성 감소
  - **에러가 전이됨**, 하지만 “self-recovering”이 가능함
    - 에러가 들어있는 암호문이 두번째 평문을 복호화하는데 XOR되기 때문에 두번째 평문의 동일한 위치에 있는 bit까지는 여전히 에러 전이
    - 그러나 그 이후에는 에러가 더 이상 전이되지 않음


#### CTR (Counter) 모드
- 스트림 암호처럼 작동
- 랜덤한 IV를 사용하며, 카운터(Counter)는 1씩 증가함