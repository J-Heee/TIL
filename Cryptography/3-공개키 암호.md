# Chapter 3. 공개키 암호

## 2020.10.10

#### 공개키 암호 등장 배경
- **대칭키 암호는 키 분배 문제(Key distribution problem)** 가 있음
- 키 분배 문제 : 대칭키 암호를 사용하려면 송신자와 수신자가 사전에 비밀키를 공유해야 하는 문제
  - 안전하게 키를 공유하기 어려움
  - 통신을 하고자 하는 전체 사용자 수만큼 키를 공유해야 함
  - ex) n명이 서로 키를 공유하기 위해서는 총 n(n-1)/2개의 키가 필요함
- 인터넷상에서는 하나의 네트워크에 통신을 하는 수많은 사람들이 있는데, 모두가 대칭키를 이용해 키를 관리하는 것은 불가능에 가까움
- 공개키 암호의 등장


### 3-1. 공개키 암호(Asymmetric cryptography)
- 공개키 암호시스템 : 암호 방식 중 **암호화와 복호화 과정에서 서로 다른 키를 사용**하는 비대칭 방식
- 메시지를 주고받는 두 사용자(A와 B)가 **각자 자신의 키 쌍(공개키, 개인키)을 가지고 있는** 구조
- **공개키(public key)** : 클라우드와 같은 공개된 게시판에 올라가 공개되어 있는 키
- **개인키(private key)** : 자신만 알 수 있게 금고와 같은 곳에 개인이 안전하게 저장한 키
- A가 B에게 암호문을 보내고 싶다면?
  - A는 B의 공개키를 공개된 게시판에서 얻어와서 그 공개키로 암호화를 수행하여 암호문 생성
  - 이 암호문은 공개키와 대응되는 개인키를 가진 B만이 복호화해서 풀어볼 수 있음


#### 대칭키 암호와 공개키 암호 비교
||대칭키 암호|공개키 암호|
|---|:---:|:---:|
|비밀키 분배|필요|불필요|
|보유 비밀키 개수<br>(n명이 비밀통신)|(n - 1)개<br>상대방별로 키가 필요|1개<br>자신의 개인키만 보유|
|키 보관 형태|비밀리에 보관|개인키는 비밀리에 보관, 공개키는 배포(공개)|
|키 길이|짧다<br>(주로 128비트, 256비트)|길다<br>(주로 1024비트, 2048비트)|
|암호화/복호화 속도|빠르다|느리다|
|부인방지|불가능|가능|
|대표 알고리즘|DES, AES, SEED, ARIA|RSA, ElGamal, DH, ECDSA|


#### 하이브리드 암호시스템 (Hybrid cryptosystem)
- 실제 우리가 사용하는 인터넷 환경에서 사용
- **대칭키 암호 + 공개키 암호** 각각의 장점을 살려서 함께 사용
- 대칭키 암호 : 대용량의 데이터 암호화 (빠른 속도)
- 공개키 암호 : 대칭키 암호의 비밀키를 암호화 (키 분배 문제 해결)
  1. 전송하고자 하는 **데이터를** 대칭키 암호에 사용되는 **비밀키로 암호화**하여 대칭키 암호문 생성
  2. 1번에서 사용한, 데이터에 비하면 상대적으로 매우 작은 크기의 **비밀키를 수신자의 공개키로 암호화**하여 공개키 암호문 생성
  3. 생성된 대칭키 암호문과 공개키 암호문 두 개를 함께 전송
  4. 수신자가 공개키 암호에서 사용되는 **개인키를 이용하여 공개키 암호문을 복호화**
  5. 대칭키 암호문에 사용되었던 비밀키가 메시지로 튀어나옴
  6. 그 **비밀키를 이용하여 대칭키 암호문을 복호화** 하면 최종적으로 데이터를 얻을 수 있음


#### 설계 원리 (기본 개념)
#### 일방향 함수 (One‐way function)
- 함수 : 𝑦 = 𝑓(𝑥)
  - 𝑥: input, 𝑓: name of function, 𝑦: output
- 일방향 함수 : **𝑥를 가지고 𝑓(𝑥)를 계산하는 것은 ‘쉬운’ 반면에, 𝑦를 가지고 𝑥를 구하는 것은 ‘어려운’ 함수 𝑓**
  - ex) 큰 수의 소인수분해
  - 메시지를 가지고 암호문을 만드는 것은 쉬운 반면, 암호문을 통해서 메시지를 얻어내는 것은 어려운 형태
- 공개키 개념을 적용하려면 모두에게 어려우면 아무도 복호화 할 수 없으므로, 개인키를 가지고 있는 사람은 쉽게 메시지를 얻어볼 수 있도록 하는 것이 추가되어야 함 -> 트랩도어 일방향 함수


#### 트랩도어 일방향 함수 (Trapdoor one‐way function)
- 𝑥를 가지고 𝑓(𝑥)를 계산하는 것은 ‘쉽고’, 𝑦를 가지고 𝑥를 구하는 것은 ‘어려운’ 반면에, **어떤 정보(트랩도어) 𝒕가 주어지면 쉽게 역함수를 계산**하여 𝑥 = 𝑓<sup>-1</sup>(𝑦)를 구할 수 있는 함수 𝑓
- **공개키 암호시스템의 기본 설계원리!**


#### 공개키 인증
- 키(key)는 결국 랜덤한 비트열인데, 그렇다면 공개키가 누구의 것인지 어떻게 확인할 수 있는가?
  - A가 자신의 공개키를 올렸는데, 공격자가 A인척 위장하면서 자신이 아는 공개키를 올릴 수도 있음. 이때 제3자가 공격자가 올린 공개키를 A의 공개키인 줄 알고 가져와서 암호문을 만들면, 공격자가 암호문을 복호화 할 수 있게 되는 문제 발생
- **공개키 인증 구조 (Public Key Infrastructure, PKI)**
  1. 클라이언트가 처음에 자신의 개인키와 공개키 쌍을 생성
  2. 개인키는 본인의 금고에 안전하게 저장
  3. 본인임을 인증할 수 있는 identifier와 함께 공개키를 CA(Certificate Authority)기관에 전송
  4. CA기관에서 본인이 맞는지를 확인 (공인인증서, 휴대폰 등을 이용), 공격자가 보낼 경우 본인인증단계를 통과할 수 없음
  5. CA기관에서 공개키에 대한 인증서 발급
  6. 공개키와 인증서가 함께 올라와 있으면 해당 키가 진짜 본인의 것임을 확인할 수 있음
- 공인인증서 : KISA(한국인터넷진흥원 - 우리나라에서 CA 역할을 하는 곳)에서 발행하는 인증서
- 사기업들에서도 사설 인증서 발행


### 3-2. 수학적 배경지식
- 공개키 암호에서는 공개키와 개인키 쌍이 존재
- 공개키로 암호화한 암호문을 개인키로 복호화해서 평문을 얻어볼 수 있는 형태
- 서로 다르게 생긴 키를 이용해서 암호화와 복호화가 된다는 것은 둘 간에 어떠한 수학적인 관계가 있음을 의미

#### 모드 연산 (Modulo operation)
- 공개키 암호에서 가장 많이 사용되는 연산 중 하나
- 바늘이 하나밖에 없는 시계 연산이라고 생각 가능
- **나눗셈을 해서 나머지를 구하는 계산**
  - 27 mod 12 = 3
  - 27을 12로 나눈 나머지 = 3
  - **27 ≡ 3 (mod 12)** -> **27과 3은 mod 12 상에서 “합동 (congruent)”**
- mod가 동일할 때만 사칙연산 가능
- **모드 덧셈**
  - (7 mod 12) + (6 mod 12) = (7 + 6) mod 12 = 13 mod 12 = 1
- **모드 뺄셈**
  - 덧셈의 역원을 계산한다고 생각하기
  - **더해서 0 되는 값 찾기!**
  - (7 + ∎) mod 12 = 0
  - ∎ = 5 (mod 12 에서는 5가 ‐7의 역할을 함)
  - 5 ≡ -7 (mod 12)
- **모드 곱셈**
  - 곱셈은 덧셈을 반복한 것
  - (7 mod 12) * 4 = (7 * 4) mod 12 = 28 mod 12 = 4
- **모드 나눗셈**
  - 모드 연산에서는 일반적인 나눗셈을 고려하지 않음
  - 하지만 곱셈의 역원은 계산할 수 있음
  - **곱셈의 역원 : 곱했을 때 1이 되는 수**
    - ex) 7의 곱셈의 역원은? 1/7, 그러나 mod 12 상에서는 1/7이라는 값 존재하지 않음
    - (7 * ∎) mod 12 = 1
    - 모든 값을 대입해서 계산해봐야 하므로 금방 계산할 수 없음
    - ∎ = 7, 7<sup>-1</sup> mod 12 = 7
  - mod 12 상에서 0~11까지의 모든 수가 곱셈의 역원을 가질까?
    - 0의 역원 : (0 × ∎) mod 12 = 1 -> 존재하지 않음
    - 1의 역원 : (1 × ∎) mod 12 = 1 -> ∎ = 1
    - 2의 역원 : (2 × ∎) mod 12 = 1 -> 존재하지 않음
    - ...
    - **12와 서로소**(12와 공약수가 1밖에 없는 수)인 수들만 곱섹의 역원을 가짐
- **모드 거듭제곱**
  - 곱셈을 반복한 것
  - 7<sup>4</sup> mod 12 = 2401 mod 12 = 1
  - 모드 연산은 **계산의 도중에 mod를 취해도 같은 결과**이므로 중간중간에 작은 값을 만들어가면서 더 편리하게 계산 가능
  - 7<sup>4</sup> mod 12 = (7 * 7 mod 12) * (7 * 7 mod 12) = (49 mod 12) * (49 mod 12) = 1 * 1 mod 12 = 1


#### 이산 대수 문제 (Discrete logarithm problem)
- 일종의 일방향 함수
- **모드 상에서 제곱근을 구하는 문제**
  - 7<sup>x</sup> mod 13 = 8 -> x = ?
  - x가 얼마나 클지 알 수 없으므로 모드 상에서는 쉽지 않은 문제
  - x = 9
- 모드 상이 아니면 제곱근을 구하는 것은 어렵지 않음
  - 7<sup>x</sup> = 49 -> x = 2
- **모드로 사용되는 숫자가 매우 크면**
  - 이산 대수 계산이 **매우 어렵고**
  - **시간이** 대단히 **많이 걸림**
  - (이산 대수를 구하는 고속 알고리즘이 없음)
- 이러한 사실을 이용해서 공개키 암호 알고리즘 설계  **(Diffie‐Hellman)**


#### 소인수분해 문제 (Integer factorization problem)
- 일종의 일방향 함수
- **매우 큰 정수를 소인수분해 하는 문제**
  - p * q = N -> N = ∎ * ∎' ?
  - (p, q는 매우 큰 두 개의 소수 사용)
  - 11 * 13 = 143 -> 143 = ?
  - 58417 * 126761 = 7,404,997,337 = ?
- 이러한 어려움에 기반해서 공개키 암호 알고리즘 설계 **(RSA 암호)**

