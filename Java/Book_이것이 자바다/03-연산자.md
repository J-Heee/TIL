# Chapter 03. 연산자

## 2021.03.06

### 3-1. 연산자와 연산식
- **연산(operations)** : 프로그램에서 데이터를 처리하여 결과를 산출하는 것
- **연산자(operator)** : 연산에 사용되는 표시나 기호
- **피연산자(operand)** : 연산되는 데이터
- **연산식(expressions)** : 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것
- 필요로 하는 피연산자의 수에 따라 연산자 구분 가능
  - 단항 연산자 : 부호 연산자, 증가/감소 연산자
  - 이항 연산자 : 단항 연산자와 삼항 연산자 이외의 두 개의 피연산자를 요구하는 연산자
  - 삼항 연산자 : 조건 연산자(조건식, A, B)
- **연산자는 반드시 하나의 값을 산출함**
  - 따라서 하나의 값이 올 수 있는 곳이면 어디든지 **값 대신 연산식 사용 가능**
  - 다른 연산식의 **피연산자 위치에도 연산식 사용 가능**

<br>
<br>

### 3-2. 연산의 방향과 우선순위
- 연산자의 연산 방향과 연산자 간의 우선순위는 정해져 있음
- 단항, 이항, 삼항 연산자 순으로 우선순위를 가짐
- 산술, 비교, 논리, 대입 연산자 순으로 우선순위를 가짐
- 복잡한 연산식에는 괄호()를 사용해서 우선순위를 정함
- 우선순위가 같은 연산자들끼리는
  - 대부분의 연산자 : 왼쪽에서부터 오른쪽으로(->) 연산
  - 단항 연산자, 부호 연산자, 대입 연산자 : 오른쪽에서 왼쪽(<-)으로 연산

<br>
<br>

### 3-3. 단항 연산자
- 피연산자가 하나뿐인 연산자
- **부호 연산자(+, -)**
  - +는 피연산자의 부호 유지, 양수 표시
  - -는 피연산자의 부호 변경, 음수 표시
  - boolean 타입과 char 타입을 제외한 나머지 기본 타입에 사용 가능
  - 부호 연산자의 산출 타입은 int 타입이 됨
- **증감 연산자(++, --)**
  - boolean 타입을 제외한 모든 기본 타입의 피연산자에 사용 가능
  
  |연산식||설명|
  |:------:|:-:|---|
  |++|피연산자|다른 연산을 수행하기 전에, 피연산자의 값을 1 증가시킴|
  |--|피연산자|다른 연산을 수행하기 전에, 피연산자의 값을 1 감소시킴|
  |피연산자|++|다른 연산을 수행한 후에, 피연산자의 값을 1 증가시킴|
  |피연산자|--|다른 연산을 수행한 후에, 피연산자의 값을 1 감소시킴|
- **논리 부정 연산자(!)**
  - 피연산자가 true이면 false로, false이면 true로 변경
  - boolean 타입에만 사용 가능
- **비트 반전 연산자(~)**
  - 피연산자를 2진수로 표현했을 때 비트값인 0은 1로, 1은 0으로 반전함
  - 정수 타입의 피연산자에만 사용 가능
  - 부호 비트의 최상위 비트를 포함해서 모든 비트가 반전되기 때문에, 부호가 반대인 새로운 값이 산출
  - 산출 타입은 int 타입이 됨
  - 비트 반전 연산자의 산출값에 1을 더하면 부호가 반대인 정수를 얻을 수 있음

<br>
<br>

### 3-4. 이항 연산자
- 피연산자가 두 개인 연산자
- **산술 연산자(+,-,*, /, %)**
  - boolean 타입을 제외한 모든 기본 타입에서 사용 가능
  - 피연산자1 **%** 피연산자2 : 피연산자1을 피연산자2로 나눈 **나머지를 구하는 연산**
  - 피연산자들의 타입이 동일하지 않을 경우, 규칙을 사용해서 피연산자들의 타입을 일치시킨 후 연산 수행
    - 피연산자들이 모두 정수 타입이고, int보다 크기가 작은 타입일 경우, 모두 int 타입으로 변환 후 연산 수행 => 산출 타입은 int
    - 피연산자들이 모두 정수 타입이고, long 타입이 있을 경우, 모두 long 타입으로 변환 후 연산 수행 => 산출 타입은 long
    - 피연산자 중 실수 타입이 있을 경우, 크기가 큰 실수 타입으로 변환 후 연산 수행 => 산출 타입은 실수 타입
  - **오버플로우 탐지**
    - 산술 연산을 할 때 주의할 점
      - 연산 후의 산출값이 산출 타입으로 충분히 표현 가능한지 살펴야 함
      - 산출 타입으로 표현할 수 없는 값이 산출되었을 경우, 오버플로우가 발생하고 쓰레기값을 얻을 수 있음
      - 바로 산술 연산자를 사용하지 말고 메소드를 이용하여 오버플로우를 탐지하는 것이 좋음
  - **정확한 계산은 정수 사용**
    - 이진 포맷의 가수를 사용하는 부동소수점 타입은 근사치로 처리하므로, 정확한 계산이 필요할 때는 사용하지 않는 것이 좋음
  - **NaN과 Infinity 연산**
    - / 또는 % 연산자 사용 시 : 좌측 피연산자가 정수 타입인 경우, **나누는 수인 우측 피연산자는 0을 사용할 수 없음**
      - 0으로 나누면 컴파일은 정상적으로 되지만, 실행 시 ArithmeticException 발생
      - 자바는 프로그램 실행 도중 예외가 발생하면, 실행이 즉시 멈추고 프로그램은 종료됨
    - **실수 타입인 0.0 또는 0.0f로 나누면**, 예외가 발생하지 않고
      - **/ 연산의 결과 : Infinity(무한대)**
      - **% 연산의 결과 : NaN(Not a Number)**
      - 위의 두 연산 결과가 나오면, 다음 연산을 수행해서는 안됨 (어떤 수와 연산하더라도 Infinity와 Nan이 산출되어 데이터 엉망)
      - `Double.inInfinite()`, `Double.isNan()` 메소드로 확인 가능
  - **입력값의 NaN 검사**
    - 부동소수점(실수)을 입력받을 때는 반드시 NaN 검사를 하여, NaN일 경우 산술 연산을 수행해서는 안됨   
- **문자열 연결 연산자(+)**
  - 문자열을 서로 결합하는 연산자
  - 피연산자 중 한쪽이 문자열이면, + 연산자는 문자열 연결 연산자로 사용되어 다른 피연산자를 문자열로 변환하고 서로 결합 
- **비교 연산자(<, <=, >, >=, ==, !=)**
  - 대소 또는 동등을 비교해서 boolean 타입인 true/false를 산출
    - 대소 연산자는 boolean 타입을 제외한 기본 타입에 사용 가능
    - 동등 연산자는 모든 타입에 사용 가능
  - 연산을 수행하기 전에 타입 변환을 통해 피연산자의 타입을 일치시킴
    - **예외) 0.1==0.1f 인 경우, 결과값으로 false 산출**
      - 부동소수점 타입은 0.1을 정확히 표현하지 못하고 근사값으로 표현되어, 0.1f는 0.1보다 큰 값이 되어버림
      - 해결책 : 피연산자를 모두 float 타입으로 강제 타입 변환 후 비교 연산, 또는 정수로 변환해서 비교 연산
  - String 타입의 문자열을 비교할 때 동등(==, !=) 비교 연산자를 사용 가능하나, 변수에 저장된 값만 비교함
    - 동일한 String 객체인지의 여부에 상관없이, **String 객체의 문자열만 비교하고 싶다면, == 연산자 대신 `equals()` 메소드를 사용**해야 함  
- **논리 연산자(&&, ||, &, |, ^, !)**
  - 논리 연산자의 피연산자는 boolean 타입만 사용 가능
  - &보다 &&가 더 효율적 (||와 |도 동일)
    - &&는 앞의 피연산자가 false라면, 뒤의 피연산자는 평가하지 않고 바로 false 산출
    - &는 두 피연산자를 모두 평가해서 산출
  - ^(배타적논리합) 연산자 : 피연산자 두 개가 서로 다른 경우에만 true 산출 (같으면 false) 
- **비트 연산자(&, |, ^, ~, <<, >>, >>>)**
  - 데이터를 비트(bit) 단위로 연산 (피연산자가 0과 1)
  - 0과 1로 표현 가능한 정수 타입만 비트 연산 가능 (실수 타입은 불가능)
  - 피연산자를 int 타입으로 자동 타입 변환 후 연산 수행, 결과도 int 타입
  - 기능에 따라
    - 비트 논리 연산자(&, |, ^, ~) : true와 false 대신 0과 1을 연산
    - 비트 이동 연산자(<<, >>, >>>) : 비트를 좌측 또는 우측으로 이동하는 연산자 
- **대입 연산자(=, +=, -=,*=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=)**
  - 오른쪽 피연산자(리터럴, 변수, 다른 연산식)의 값을 좌측 피연산자인 변수에 저장
  - 복합 대입 연산자 : 정해진 연산을 수행한 후 결과를 변수에 저장
  - 모든 연산자들 중 가장 낮은 연산 순위
  - 연산의 진행 방향은 오른쪽에서 왼쪽 

<br>
<br>

### 3-5. 삼항 연산자(조건 연산식)
- 삼항 연산자(?:)는 세 개의 피연산자를 필요로 하는 연산자
- **조건식 ? (값 또는 연산식1) : (값 또는 연산식2)**
  - 조건식의 연산 결과가 true일 경우, 삼항 연산자의 결과는 (값 또는 연산식1)
  - 조건식의 연산 결과가 false일 경우, 삼항 연산자의 결과는 (값 또는 연산식2)

<br>
<br>

### Reference
- [이것이 자바다](http://www.yes24.com/Product/Goods/15651484?OzSrank=2) - 신용권 저. 한빛미디어. 2015