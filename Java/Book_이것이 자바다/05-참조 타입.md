# Chapter 05. 참조 타입

## 2021.03.07

### 5-1. 데이터 타입 분류
- 자바의 데이터 타입은 크게
  - 기본 타입(원시 타입: primitive type) : 정수, 실수, 문자, 논리 리터럴을 저장하는 타입
    - 실제 값을 변수 안에 저장 
  - **참조 타입(reference type) : 객체(Object)의 주소를 참조하는 타입**
    - **배열, 열거, 클래스, 인터페이스** 타입
    - 메모리의 주소 값을 변수 안에 저장 (주소를 통해 객체를 참조 -> 참조 타입)

<br>
<br>

### 5-2. 메모리 사용 영역
- JVM이 사용하는 메모리 영역
  - java.exe로 JVM이 시작되면, JVM은 운영체제에서 할당받은 메모리 영역(Runtime Data Area)을 세부 영역으로 구분해서 사용
- **메소드(Method) 영역**
  - JVM이 시작할 때 생성되고, 모든 스레드가 공유하는 영역 
  - 코드에서 사용되는 클래스(.class)들을 클래스 로더로 읽어, 클래스별로 런타임 상수풀(runtime constant pool), 필드(field) 데이터, 메소드(method) 데이터, 메소드 코드, 생성자(constructor) 코드 등을 분류해서 저장
- **힙(Heap) 영역**
  - 객체와 배열이 생성되는 영역
  - 힙 영역에서 생성된 객체와 배열은, JVM 스택 영역의 변수나 다른 객체의 필드에서 참조
  - 참조하는 변수나 필드가 없다면, 의미 없는 객체가 되어 쓰레기로 취급
    - **JVM은 쓰레기 수집기(Garbage Collector)를 실행시켜 쓰레기 객체를 힙 영역에서 자동으로 제거**
- **JVM 스택(Stack) 영역** 
  - 각 스레드마다 하나씩 존재하며, 스레드가 시작될 때 할당됨
    - 추가적으로 스레드를 생성하지 않았다면, main 스레드만 존재하므로 JVM 스택도 하나
  - JVM 스택은 메소드를 호출할 때마다 프레임(Frame)을 추가(push)하고, 메소드가 종료되면 해당 프레임을 제거(pop)하는 동작 수행
  - 프레임 내부에는 로컬 변수 스택이 존재
    - 기본 타입 변수와 참조 타입 변수가 추가(push)되거나 제거(pop)됨
    - 변수가 이 영역에 생성되는 시점은 초기화 될 때(최초로 변수에 값이 저장될 때) 
    - 변수는 선언된 블록 안에서만 스택에 존재, 블록을 벗어나면 스택에서 제거
  - 기본 타입 변수는 스택 영역에 직접 값을 가지고 있음
  - **참조 타입 변수는 값이 아니라, 힙 영역이나 메소드 영역의 객체 주소를 가짐** 

<br>
<br>

### 5-3. 참조 변수의 ==, != 연산
- 기본 타입 변수의 ==, != 연산 : 변수의 값이 같은지 여부를 조사
- 참조 타입 변수의 ==, != 연산 : **동일한 객체를 참조하는지 여부를 조사**
  - 참조 타입 변수의 값은 힙 영역의 객체의 주소, 결국 주소 값을 비교하는 것 

<br>
<br>

### 5-4. null과 NullPointerException
- **참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 null 값을 가질 수 있음**
  - null로 초기화된 참조 변수는 스택 영역에 생성
- 예외(Exception) : 프로그램 실행 도중에 발생하는 오류
- **NullPointerException : 프로그래머의 실수로 null 값을 가지고 있는 참조 타입 변수를 사용하면 발생**
  - 참조 타입 변수가 null을 가지고 있을 경우, 참조할 객체가 없으므로 사용 불가
  - 해결책 : 해당 변수를 추적해서 객체를 참조하도록 수정  

<br>
<br>

### 5-5. String 타입
- 자바는 문자열을 String 변수에 저장
  ```
  String 변수 = "문자열";
  ```
- 정확히는 문자열은 String 객체로 생성되고, 변수는 String 객체를 참조하는 것
  - 문자열이 직접 변수에 저장되는 것이 아님
- new 연산자를 사용해서 직접 String 객체 생성도 가능
  - **new 연산자(객체 생성 연산자) : 힙 영역에 새로운 객체를 만들 때 사용하는 연산자**
- **자바는 문자열 리터럴이 동일하다면, String 객체를 공유하도록 되어 있음**
- **문자열 리터럴로 생성하느냐, new 연산자로 생성하느냐에 따라 비교 연산자의 결과가 달라질 수 있음**
  - 동일한 문자열 리터럴로 String 객체를 생성했을 경우, == 연산의 결과는 true
  - new 연산자로 String 객체를 생성했을 경우, == 연산의 결과는 false
  - == 연산자는 변수에 저장된 객체 번지가 동일한지를 검사하기 때문
    ```
    String name1 = "미니언";
    String name2 = "미니언";
    String name3 = new String("미니언");
    ```
    - name1==name2의 결과는 true
    - name1==name3의 결과는 false
- 동일한 String 객체의 여부에 상관없이, **문자열만을 비교할 때는 String 객체의 `equals()` 메소드 사용**
  - 원본 문자열과 매개값으로 주어진 비교 문자열이 동일한지 비교 후 true 또는 false 리턴
    ```
    boolean result = str1.equals(str2);
    ```
- String 변수는 참조 타입이므로 초기값으로 null을 대입하여 참조하는 객체가 없음을 나타낼 수 있음
- 참조를 잃은 String 객체는, JVM이 쓰레기 객체로 취급하여 Garbage Collector를 구동시켜 메모리에서 자동 제거

<br>
<br>

### 5-6. 배열 타입
  
#### 배열
- **배열 : 같은 타입의 데이터를 연속된 공간에 나열시키고, 각 데이터에 인덱스를 부여해 놓은 자료구조**
- 인덱스(index) : 각 항목의 데이터를 읽거나, 저장하는데 사용
  - 배열 이름 옆 대괄호[ ]에 기입
- **배열은 선언과 동시에 저장할 수 있는 데이터 타입이 결정**
  - 다른 타입의 값을 저장하려고 하면 타입 불일치(Type mismatch) 컴파일 오류 발생
- **한 번 생성된 배열은 길이를 늘리거나 줄일 수 없음**

<br>

#### 배열 선언
- 배열 변수 선언 (두 가지 방법)
  ```
  타입[] 변수;             # 타입은 배열에 저장될 데이터의 타입
  타입 변수[];
  ```
- 배열 변수는 참조 변수
  - 객체인 배열은 힙 영역에 생성, 배열 변수는 힙 영역의 배열 객체를 참조
  - 참조할 배열 객체가 없다면, 배열 변수는 null로 초기화 가능
    - 배열 변수가 null 값을 가진 상태에서 값을 저장하거나 읽으면, NullPointerException 발생 

<br>

#### 값 목록으로 배열 생성
- 배열 항목에 저장될 값의 목록이 있다면, 간단하게 배열 객체 생성 가능
  ```
  데이터타입[] 변수 = { 값0, 값1, 값2, 값3, ... };
  ```
  - 중괄호는 주어진 값들을 항목으로 가지는 배열 객체를 힙에 생성, 배열 객체의 주소를 리턴
  - 배열 변수는 리턴된 주소를 저장하여 참조
  - **주의할 점) 배열 변수를 이미 선언한 후에, 다른 실행문에서 중괄호를 사용한 배열 생성은 허용되지 않음**
  - **해결책) new 연산자를 사용해서 값 목록을 지정해주기**
    ```
    타입[] 변수 = null;
    변수 = new 타입[] { 값0, 값1, 값2, 값3, ... };
    ``` 
  - 매소드의 매개값이 배열일 경우도 마찬가지로 해결 가능

<br>

#### new 연산자로 배열 생성
- 값의 목록을 가지고 있지 않지만, 향후 값들을 저장할 배열을 미리 만들고 싶다면 new 연산자로 배열 객체 생성 가능
  ```
  타입[] 변수 = new 타입[길이];
  ```
  - 길이 : 배열이 저장할 수 있는 값의 수
- new 연산자로 배열을 처음 생성할 경우, 배열은 자동적으로 기본값으로 초기화
  - 정수와 실수 타입의 배열은 대부분 기본값 0으로 초기화
  - 참조 타입의 배열은 보통 null 값으로 초기화
  - 논리 타입(boolean)의 배열은 false로 초기화

<br>

#### 배열 길이
- 배열의 길이 : 배열에 저장할 수 있는 전체 항목 수
- 배열 객체의 length 필드를 읽어 코드에서 배열 길이를 얻을 수 있음
  ```
  배열변수.length();
  ```
- length 필드는 읽기 전용 필드이므로, 값을 바꿀 수 없음
- length 필드는 for문을 사용해서 배열 전체를 루핑할 때 유용하게 사용 가능
  - **배열의 인덱스 범위 : 0 - (길이-1)**
  - 인덱스를 초과해서 사용하면 ArrayIndexOutOfBoundsException 발생

<br>

#### 커맨드 라인 입력
- main() 메소드의 매개값인 `String[] args`가 필요한 이유
  ```
  public static void main(String[] args) { ... }
  ```
- "java 클래스"로 프로그램을 실행하면, JVM은 길이가 0인 String 배열을 먼저 생성하고, main() 메소드를 호출할 때 매개값으로 전달
- "java 클래스" 뒤에 공백으로 구분된 문자열 목록을 주고 실행하면, 문자열 목록으로 구성된 String[] 배열이 생성되고, main() 메소드를 호출할 때 매개값으로 전달
  ```
  java 클래스 문자열0 문자열1 문자열2 ... 문자열n-1
  ```
  ```
  String[] args = { 문자열0, 문자열1, ... 문자열n-1 };
  ```
- **main() 메소드는 `String[] args` 매개 변수를 통해서, 커맨드 라인에서 입력된 데이터의 수(배열의 길이)와 입력된 데이터(배열의 항목 값)를 알 수 있음**

<br>

#### 다차원 배열
- **2차원 배열 : 값들이 행과 열로서 구성된 배열**
  - 수학의 행렬처럼, 가로 인덱스와 새로 인덱스를 사용
- 자바는 2차원 배열을 중첩 배열 방식으로 구현
  ```
  int[][] scores = new int[2][3];           # 2(행) x 3(열) 행렬 생성
  ```
  - 위의 코드는 세 개의 배열 객체를 생성
  - 배열 변수인 scores는 길이 2인 배열A를 참조
  - 배열A의 scores[0]은 길이 3인 배열B를 참조 (배열을 참조하는 변수 역할)
    - scores[0][1]은 배열B의 인덱스 1 값 의미 
  - 배열A의 scores[1]은 길이 3인 배열C를 참조 (배열을 참조하는 변수 역할)
    - scores[1][0]은 배열C의 인덱스 0 값 의미
- 자바는 일차원 배열이 서로 연결된 구조로 다차원 배열을 구현하기 때문에, 수학 행렬 구조가 아닌 **계단식 구조를 가질 수 있음**
- 그룹화된 값 목록을 가지고 있다면, 중괄호 안에 다시 중괄호를 사용해서 값 목록을 나열
  ```
  타입[][] 변수 = { {값1, 값2, ...}, {값1, 값2, ...}, ... };
  ```

<br>

#### 객체를 참조하는 배열
- 기본 타입 배열은 각 항목에 직접 값을 가지고 있음
- 참조 타입 배열은 각 항목에 객체의 주소를 가지고 있음
  - 참조 타입 배열의 항목은 참조 변수와 동일하게 취급 

<br>

#### 배열 복사
- 배열은 한 번 생성하면 크기를 변경할 수 없음
  - 더 많은 저장 공간이 필요하다면, 보다 큰 배열을 새로 만들고 이전 배열로부터 항목 값들을 복사해야 함
- 배열 간의 항목 값들을 복사하려면 
  - for문 사용
  - `System.arraycopy()` 메소드를 사용
    ```
    System.arraycopy(Object src, int srcPos, Object dest, int destPos, in length);
    ``` 
    - src : 원본 배열
    - srcPos : 원본 배열에서 복사할 항목의 시작 인덱스
    - dest : 새 배열
    - destPos : 새 배열에서 붙여넣을 시작 인덱스
    - length : 복사할 개수
- **얕은 복사(shallow copy)** : 참조 타입 배열의 배열 복사의 경우, 복사되는 값이 객체의 주소이므로, **새 배열의 항목은 이전 배열의 항목이 참조하는 객체와 동일**
- **깊은 복사(deep copy) : 참조하는 객체도 별도로 생성하는 것** 

<br>

#### 향상된 for문
- 자바5부터 배열 및 컬렉션 객체를 좀 더 쉽게 처리할 목적으로 향상된 for문 제공
- 향상된 for문은
  - **반복 실행을 하기 위해 카운터 변수와 증감식을 사용하지 않음**
  - 배열 및 컬렉션 항목의 개수만큼 반복하고, 자동적으로 for문을 빠져나감
- for문의 괄호( )에는 **배열에서 꺼낸 항목을 저장할 변수 선언, 콜론(:), 배열**을 나란히 작성
  ```
  int[] scores = {95, 71, 84, 93, 87};
  for(int score : scores) {                     // for(타입 변수 : 배열)
      ...                                       // 실행문
  }
  ```
  1. for문이 처음 실행될 때, 배열에서 가져올 첫 번째 값이 존재하는지 평가
  2. 가져올 값이 존재하면, 해당 값을 변수에 저장
  3. 실행문 실행
  4. 실행문이 모두 실행되면, 다시 루프를 돌아 배열에서 가져올 다음 값이 존재하는지 평가
  5. 만약 다음 항목이 존재하면 위의 순서 반복, 존재하지 않으면 for문 종료
  - -> for문의 반복 횟수는 배열의 항목 수

<br> 
<br>

### 5-7. 열거 타입
- **열거 타입(enumeration type) : 한정된 값만을 가지는 데이터 타입**
- 열거 타입은 몇 개의 **열거 상수(enumeration constant)** 중에서 하나의 상수를 저장

<br>

#### 열거 타입 선언
- 열거 타입을 선언하기 위해서는, 먼저 열거 타입의 이름을 정하고, **열거 타입 이름으로 소스 파일(.java)을 생성해야 함**
  - 열거 타입 이름은
    - 관례적으로 첫 문자를 대문자, 나머지는 소문자로 구성
    - 여러 단어로 구성된 이름이라면, 단어 첫 문자는 대문자로
    - 소스 파일명과 대소문자가 모두 일치해야 함
  - 소스 파일의 내용으로는
    - 열거 타입 선언
    - **public enum 키워드는 열거 타입을 선언하기 위한 키워드**
  - 열거 상수 선언
    - 열거 타입의 값으로 사용
    - 관례적으로 열거 상수는 모두 대문자로 작성
    - 여러 단어로 구성될 경우는 단어 사이를 밑줄(_)로 연결하는 것이 관례
  ```
  public enum Week {MONDAY, TUESDAY, WEDNESDAY, THURSDAY, ... }
  // Week이 열거 타입 이름
  ```

<br>

#### 열거 타입 변수
- 열거 타입을 선언했다면 열거 타입 사용 가능
- 열거 타입도 하나의 데이터 타입이므로 변수를 선언하고 사용해야 함
  ```
  열거타입 변수;
  Week today;               // 열거 타입이 Week일 경우
  ```
- 열거 타입 변수 선언 후, 열거 상수 지정 가능
  - **열거 상수는 단독으로 사용 불가, 반드시 `열거타입.열거상수`로 사용**
  ```
  열거타입 변수 = 열거타입.열거상수;
  Week today = Week.SUNDAY;
  ``` 
- **열거 타입도 참조 타입이므로, null 값 저장 가능**
  - **열거 상수는 열거 객체로 생성됨**
  - 열거 타입 Week의 경우
    - MONDAY부터 SUNDAY까지의 열거 상수는 총 7개의 Week 객체로 힙 영역에 생성됨
    - 메소드 영역에 생성된 열거 상수가 해당 Week 객체를 각각 참조
      ```
      Week today = Week.SUNDAY;
      ```
    - 열거 타입 변수 today는 스택 영역에 생성
    - today에 저장되는 값은 Week.SUNDAY 열거 상수가 참조하는 객체의 주소
    - 따라서, 열거 상수 Week.SUNDAY와 today 변수는 서로 같은 Week 객체를 참조하는 것
    - -> `today(변수) == Week.SUNDAY(상수)` 연산 결과는 true
- **자바는 컴퓨터의 날짜 및 요일, 시간을 프로그램에서 사용할 수 있도록 하기 위해 Date, Calendar, LocalDateTime 등의 클래스를 제공**
  - LocalDateTime은 자바8부터 지원하는 API
  ```
  import java.util.Calendar;

  Calendar now = Calendar.getInstance();        // Calendar 변수 선언, 메소드가 리턴하는 Calendar 객체를 저장

  // get() 메소드 이용
  int year = now.get(Calendar.YEAR);            // 년
  int day = now.get(Calendar.DAY_OF_MONTH);     // 일
  int hour = now.get(Calendar.HOUR);            // 시간
  ```

<br>

#### 열거 객체의 메소드
- 힙 영역의 열거 객체는 열거 상수의 문자열을 내부 데이터로 가짐
- 모든 열거 타입은 컴파일 시 Enum 클래스를 상속
  - -> **열거 객체에서 java.lang.Enum 클래스에 선언된 메소드 사용 가능**
- **`name()` 메소드**
  - 열거 객체가 가지고 있는 문자열을 리턴 (리턴 타입 : String)
  - 리턴되는 문자열은 열거 타입을 정의할 때 사용한 상수 이름과 동일
- **`ordinal()` 메소드**
  - 전체 열거 객체 중 몇 번째 열거 객체인지 순번(0부터 시작)을 리턴 (리턴 타입 : int)
- **`compareTo()` 메소드**
  - 매개값으로 주어진 열거 객체를 기준으로, 전후로 몇 번째에 위치하는지 순번 차이를 리턴 (리턴 타입 : int)
    - 열거 객체가 매개값의 열거 객체보다 순번이 빠르면 음수, 늦으면 양수가 리턴
- **`valueOf()` 메소드**
  - 매개값으로 주어진 문자열과 동일한 문자열을 가지는 열거 객체를 리턴 (리턴 타입 : 열거 타입)
  - 외부로부터 문자열을 입력받아, 열거 객체로 변환할 때 유용하게 사용
- **`values()` 메소드**
  - 열거 타입의 모든 열거 객체들을 배열로 만들어 리턴 (리턴 타입 : 열거 배열)

<br>
<br>

### Reference
- [이것이 자바다](http://www.yes24.com/Product/Goods/15651484?OzSrank=2) - 신용권 저. 한빛미디어. 2015