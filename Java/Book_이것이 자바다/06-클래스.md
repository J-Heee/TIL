# Chapter 06. 클래스

## 2021.03.12

### 6-1. 객체 지향 프로그래밍(OOP: Object Oriented Programming)
- 부품에 해당하는 객체들을 먼저 만들고, 객체들을 하나씩 조립해서 완성된 프로그램을 만드는 기법

<br>

#### 객체(Object)
- 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서, 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것
- 객체는 속성(필드: field)과 동작(메소드: method)으로 구성
- **객체 모델링(Object Modeling)** : 현실 세계의 객체를 소프트웨어 객체로 설계하는 것
  - 현실 세계 객체의 속성과 동작을 추려내어, 소프트웨어 객체의 필드와 메소드로 정의하는 과정

<br>

#### 객체의 상호작용
- 소프트웨어에서 객체들은 각각 독립적으로 존재하고, 다른 객체와 서로 상호작용하면서 동작함
- 메소드 : 객체들 사이의 상호작용 수단
- 메소드 호출 : 객체가 다른 객체의 기능을 이용하는 것
  - 객체에 도트(.) 연산자를 붙이고, 메소드 이름을 기술하는 형태
  ```
  리턴값 = 전자계산기객체.메소드(매개값1, 매개값2, ...);
  ``` 
  - **도트 연산자 : 객체의 필드와 메소드에 접근할 때 사용**
  - 매개값 : 메소드를 실행하기 위해 필요한 데이터
  - 리턴값 : 메소드가 실행하고 나서, 호출한 곳으로 돌려주는 값

<br>

#### 객체 간의 관계
- 객체는 개별적으로 사용 가능하지만, 대부분 다른 객체와 관계를 맺고 있음
  - 집합 관계 : 하나는 부품이고, 하나는 완성품에 해당
  - 사용 관계 : 객체 간의 상호작용
  - 상속 관계 : 상위(부모) 객체를 기반으로, 하위(자식) 객체를 생성하는 관계
- OOP : 만들고자 하는 완성품인 객체를 모델링하고, 집합 관계에 있는 부품 객체와 사용 관계에 있는 객체를 하나씩 설계한 후 조립하는 방식으로 프로그램 개발

<br>

#### 객체 지향 프로그래밍의 특징
- **캡슐화(Encapsulation)**
  - **객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것**
  - 외부 객체는 객체 내부의 구조를 알지 못하며, 객체가 노출해서 제공하는 필드와 메소드만 이용 가능
    - 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하기 위해 캡슐화하여 보호
  - 자바는 캡슐화된 멤버를 노출시킬 것인지의 유무를 결정하기 위해 접근 제한자 사용
  - **접근 제한자(Access Modifier)** : 객체의 필드와 메소드의 사용 범위를 제한함으로써 외부로부터 보호 
- **상속(Inheritance)**
  - **상위 객체가 가지고 있는 필드와 메소드를 하위 객체에게 물려주어, 하위 객체가 사용할 수 있도록 해주는 것**
  - 상위 객체를 재사용해서 하위 객체를 쉽고 빠르게 설계 가능
  - 이미 잘 개발된 객체를 재사용해서 새로운 객체를 만들기 때문에 반복된 코드의 중복을 줄여줌
  - 상위 객체의 수정으로 모든 하위 객체들의 수정 효과를 가져옴
    - 유지 보수 시간을 최소화
- **다형성(Polymorphism)**
  - **같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질**
    - 코드 측면 : 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록
  - 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용
    - 부모 타입 - 모든 자식 객체 대입 가능
    - 인터페이스 타입 - 모든 구현 객체 대입 가능
  - 객체의 부품화가 가능하도록 하는 효과

<br>
<br>

### 6-2. 객체와 클래스
- 객체 지향 프로그래밍에서, 메모리에서 사용하고 싶은 객체가 있다면 우선 설계도로 해당 객체를 만드는 작업 필요
- **클래스(class)** : 자바에서의 설계도, 객체를 생성하기 위한 필드와 메소드가 정의되어 있음
- **인스턴스(instance)** : 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 함
- **인스턴스화** : 클래스로부터 객체를 만드는 과정
  - 하나의 클래스로부터 여러 개의 인스턴스 생성 가능
- OOP의 세 가지 단계
  1. 클래스 설계
  2. 설계된 클래스를 가지고 사용할 객체 생성
  3. 생성된 객체 이용

<br>
<br>

### 6-3. 클래스 선언
- 사용하고자 하는 객체를 구상했다면, 그 객체의 대표 이름을 하나 결정하고 이것을 클래스 이름으로 설정
- 클래스 이름
  - 자바의 식별자 작성 규칙에 따라서 생성
  - 영어 대소문자를 구분
  - 관례적으로, 클래스 이름이 단일 단어라면 첫 자를 대문자로, 나머지는 소문자로 작성
  - 관례적으로, 서로 다른 단어가 혼합된 이름이라면 각 단어의 첫 머리 글자는 대문자로 작성
- 소스 파일 생성
  - **"클래스이름.java"로 생성**
  - 소스 파일 이름은 클래스 이름과 동일하도록 설정
- 클래스 선언
  - 소스 파일을 열고 클래스 선언
  ```
  public class 클래스이름 {   // 클래스 선언의 시작
    
  }   // 클래스 선언의 끝
  ```
  - 일반적으로 소스 파일당 하나의 클래스를 선언, 하지만 두 개 이상의 클래스 선언도 가능
    - **파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있음**
    - 소스 파일을 컴파일하면 바이트 코드 파일은(.class) 클래스를 선언한 개수만큼 생성
    - 소스 파일은 클래스 선언을 담고 있는 저장 단위라고 생각 가능

<br>
<br>

### 6-4. 객체 생성과 클래스 변수
- 클래스로부터 객체를 생성하는 방법
  ```
  클래스 변수 = new 클래스();
  ```
  - new 연산자 : 클래스로부터 객체를 생성하는 연산자
    - new 연산자 뒤에는 `클래스()` 형태의 생성자 위치
    - 메모리 힙(heap) 영역에 객체를 생성하고, 객체의 주소를 리턴
    - 참조 타입인 클래스 변수(스택 영역)에 주소를 저장하여, 변수를 통해 객체 사용 가능
- 클래스의 두 가지 용도
  - **라이브러리(API: Application Program Interface)용** : 다른 클래스에서 이용할 목적으로 설계
  - **실행용** : 프로그램의 실행 진입점인 main() 메소드를 제공하는 역할
  - 프로그램 전체에서 사용되는 클래스가 100개라면, 99개는 라이브러리이고 단 하나가 실행 클래스

<br>
<br>

### 6-5. 클래스의 구성 멤버
- 클래스에는 객체가 가져야 할 구성 멤버가 선언, 구성 멤버들은 생략되거나 복수 개가 작성될 수 있음
- **필드(Field) : 객체의 데이터가 저장되는 곳**
  - 선언 형태는 변수와 비슷하지만, 변수라고 부르지 않음
  - 변수는 생성자와 메소드 내에서만 사용되고, 생성자와 메소드가 실행 종료되면 자동 소멸
  - 필드는 생성자와 메소드 전체에서 사용되며, 객체가 소멸되지 않는 한 객체와 함께 존재 
- **생성자(Constructor) : 객체 생성 시 초기화 담당**
  - new 연산자로 호출되는 특별한 중괄호 블록
  - 메소드와 비슷하게 생겼지만, 클래스 이름으로 되어 있고 리턴 타입이 없음
- **메소드(Method) : 객체의 동작에 해당하는 중괄호 블록**
  - 메소드 이름을 가짐
  - 호출하면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행
    - 필드를 읽고 수정하는 역할
    - 다른 객체를 생성해서 다양한 기능을 수행하는 역할
    - 객체 간의 데이터 전달의 수단

<br>
<br>

### 6-6. 필드(Field)
- 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳
- **필드 선언**
  - 클래스 중괄호 블록 어디서든 가능
    - 생성자 선언과 메소드 선언의 앞과 뒤 어떤 곳에서도 가능
    - 생성자와 메소드 중괄호 블록 내부에는 선언 불가능 (로컬 변수가 됨)
  ```
  타입 필드 [ = 초기값] ;
  ```
  - 타입 : 필드에 저장할 데이터의 종류, 기본 타입과 참조 타입 모두 가능
  - 필드의 초기값은 선언 시 주어질 수도 있고, 생략될 수도 있음
  - **초기값이 지정되지 않은 필드들은 객체 생성 시 자동으로 기본 초기값으로 설정**
    - 정수 타입은 0, 실수 타입은 0.0, 논리 타입은 false, 참조 타입은 null 값이 기본 초기값 
- **필드 사용**
  - 필드값을 읽고, 변경하는 작업 의미
  - 클래스 내부의 생성자나 메소드에서 사용할 경우 - 단순히 필드 이름으로 읽고 변경
  - **클래스 외부에서 사용할 경우 - 클래스로부터 객체를 먼저 생성한 후, 필드 사용**
    - 필드는 객체에 소속된 데이터로, 객체가 존재하지 않으면 필드도 존재하지 않음  
  - 필드는 생성자와 모든 메소드에서 사용 가능
    - 변수는 자신이 선언된 생성자 또는 메소드 블록 내부에서만 사용 가능

<br>
<br>

### 6-7. 생성자(Constructor)
- new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출
- 객체의 초기화를 담당
  - 객체 초기화 : 필드 초기화 또는 메소드를 호출해서 객체를 사용할 준비를 하는 것
- 생성자를 실행시키지 않고는 객체 생성 불가능
  - 생성자가 성공적으로 실행되면 힙 영역에 객체가 생성되고, 객체의 주소가 리턴
  - 생성자가 성공적으로 실행되지 않고 예외(에러)가 발생했다면, 객체는 생성되지 않음 
- **기본 생성자(Default Constructor)**
  - 모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있음
  - **클래스 내부에 생성자 선언을 생략할 경우, 컴파일러는 중괄호 블록 내용이 비어있는 기본 생성자를 바이트 코드에 자동으로 추가**
  - 클래스에 명시적으로 선언한 생성자가 한 개라도 있으면, 컴파일러는 기본 생성자를 추가하지 않음
  ```
  [public] 클래스() { }
  ```
  - 클래스가 public class로 선언되면 기본 생성자에도 public이 붙음 (그냥 class로만 선언되면 기본 생성자에도 public 붙지 않음)
- **생성자 선언**
  - 명시적으로 생성자를 선언하는 이유 : 객체를 다양하게 초기화하기 위해
  ```
  클래스( 매개변수선언, ... ) {
    // 객체의 초기화 코드
  }
  ```
  - 생성자는 메소드와 비슷한 모양이지만, 리턴 타입이 없고 클래스 이름과 동일
  - 매개 변수 
    - 선언은 생략도 가능하고, 여러 개의 선언도 가능
    - new 연산자로 생성자를 호출할 때, 외부의 값을 생성자 블록 내부로 전달하는 역할
  - 클래스에 생성자가 명시적으로 선언되어 있을 경우, 반드시 선언된 생성자를 호출해서 객체를 생성해야만 함
- **필드 초기화**
  - 클래스로부터 객체가 생성될 때, 필드는 기본 초기값으로 자동 설정
  - 다른 값으로 초기화를 하고 싶다면
    1. **필드를 선언할 때 초기값을 주는 방법**
       - 동일한 클래스로부터 생성되는 객체들은 모두 같은 데이터를 가지게 됨
       - 객체 생성 시점에는 필드의 값이 모두 동일
       - 객체 생성 후에는 변경 가능
    2. **생성자에서 초기값을 주는 방법**
       - 객체 생성 시점에서, 외부에서 제공되는 다양한 값들로 초기화되어야 하는 경우 사용
  - **관례적으로 초기화시킬 필드와 동일한 이름을 갖는 매개 변수를 사용**
    - 이 경우 필드와 매개 변수 이름이 동일하므로, 생성자 내부에서 해당 필드에 접근 불가
      - 동일한 이름의 매개 변수가 사용 우선순위가 더 높음
    - 해결책) 필드 앞에 `this.` 붙이기
      - this는 객체 자신의 참조를 의미
      - **`this.필드`는 this라는 참조 변수로 필드를 사용하는 것과 동일**
- **생성자 오버로딩(Overloading)**
  - 매개 변수를 달리하는 생성자를 여러 개 선언하는 것
  - 자바는 다양한 방법으로 객체를 생성할 수 있도록 생성자 오버로딩을 제공
  ```
  public class Car {

    Car() { ... }
    Car(String model) { ... }
    Car(String model, String color) { ... }
    Car(String model, String color, int maxSpeed) { ... }

  }
  ```
  - **주의할 점) 매개 변수의 타입, 개수, 순서가 다르게 선언해야 함**
  - 생성자가 오버로딩되어 있을 경우, new 연산자로 생성자를 호출할 때 제공되는 매개값의 타입과 수에 의해 호출될 생성자 결정
- **다른 생성자 호출(this())**
  - 생성자 오버로딩이 많아질 경우, 생성자 간의 중복된 코드 발생 가능
    - 매개 변수의 수만 다르게 하고, 필드 초기화 내용이 비슷한 생성자에서 중복이 많이 발생 
  - 해결책) **필드 초기화 내용은 한 생성자에만 집중적으로 작성하고, 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선**
  ```
  클래스( [매개변수선언, ...] ) {
    this( 매개변수, ..., 값, ... );         // 클래스의 다른 생성자 호출
    실행문;
  }
  ```
  - **생성자에서 자신의 다른 생성자를 호출할 때는 `this()` 코드 사용**
    - `this()`는 반드시 생성자의 첫줄에서만 허용
    - 매개값은 호출되는 생성자의 매개 변수 타입에 맞게 제공해야 함
    - `this()` 다음에는 원래 생성자로 돌아와서 추가적인 실행문 진행 가능

<br>
<br>

### Reference
- [이것이 자바다](http://www.yes24.com/Product/Goods/15651484?OzSrank=2) - 신용권 저. 한빛미디어. 2015