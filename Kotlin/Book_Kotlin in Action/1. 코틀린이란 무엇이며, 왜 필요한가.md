# 1. 코틀린이란 무엇이며, 왜 필요한가?
- 코틀린은 자바 플랫폼에서 돌아가는 새로운 프로그래밍 언어로, 간결하고 실용적이며, 자바 코드와의 상호운용성을 중시함

<br>

## 1.1 코틀린 맛보기
- http://try.kotl.in 에서 쉽게 코드 실행 가능
- 예제) Person 클래스 정의 -> 사람을 모아둔 컬렉션 생성 -> 가장 나이 많은 사람을 찾아서 출력
  ```kotlin
  data class Person (val name: String,  // 데이터 클래스
                     val age: Int? = null)  // null이 될 수 있는 타입과 파라미터 디폴트 값

  fun main (args: Array<String>) {  // 최상위 함수
      val persons = listOf(Person("영희"), 
                           Person("쳘수", age = 29))    // 이름 붙인 파라미터

      val oldest = persons.maxBy { it.age ?: 0 }    // 람다 식과 엘비스 연산자
      println("나이가 가장 많은 사람: $oldest");    // 문자열 템플릿
  }

  // 나이가 가장 많은 사람: Person(name=쳘수, age=29)
  ```

<br>
<br>

## 1.2 코틀린의 주요 특성

### 1.2.1 대상 플랫폼: 서버, 안드로이드 등 자바가 실행되는 모든 곳
- 코틀린의 주목적: 현재 자바가 사용되고 있는 모든 용도에 적합하면서 더 간결하고 생산적이며 안전한 대체 언어를 제공하는 것
- 코틀린을 활용할 수 있는 일반적인 영역
  - 서버상의 코드
  - 안드로이드 디바이스에서 실행되는 모바일 애플리케이션 
  - 인텔의 멀티OS 엔진을 사용하여 코틀린을 iOS 디바이스에서 실행 가능
  - 자바스크립트로도 컴파일 가능, 따라서 코틀린 코드를 브라우저나 노드에서 실행 가능

### 1.2.2 정적 타입 지정 언어
- 정적 타입(statically typed) 지정 언어
  - 자바, 코틀린
  - 모든 프로그램 구성 요소의 타입을 컴파일 시점에서 알 수 있음
  - 프로그램 안에서 객체의 필드나 메소드 사용할 때마다 컴파일러가 타입 검증을 해줌
- 코틀린에서는 모든 변수의 타입을 개발자가 직접 명시할 필요가 없음
  - 코틀린 컴파일러가 문맥으로부터 변수 타입을 자동으로 유추하기 때문
  ```kotlin
  var x = 1
  ```
  - 변수를 정의하면서 정수 값으로 초기화했으므로, 코틀린이 변수의 타입이 Int라는 것을 자동으로 알아냄
  - 타입 추론(type inference): 컴파일러가 문맥을 고려해 변수 타입을 결정하는 기능
- 정적 타입 지정의 장점
  - 성능
    - 메소드 호출이 더 빠름 (실행 시점에 어떤 메소드를 호출할지 알아내는 과정이 없으므로) 
  - 신뢰성
    - 컴파일러가 정확성을 검증하기 때문에 실행 시에 프로그램이 오류로 중단될 가능성 적음
  - 유지 보수성
    - 처음 보는 코드를 다룰 때 더 쉬움 (코드에서 다루는 객체가 어떤 타입인지 알 수 있기 때문)
  - 도구 지원
    - 더 안전하게 리팩토링 가능, 도구는 더 정확한 코드 완성 기능 제공
- 코틀린에서는 null이 될 수 있는 타입을 지원
  - 컴파일 시점에 null pointer exception이 발생할 수 있는지 검사 가능하여 신뢰성 높임

### 1.2.3 함수형 프로그래밍과 객체지향 프로그래밍
- 함수형 프로그래밍의 핵심 개념
  - 일급 시민인(first-class) 함수
    - 함수를 일반 값처럼 다룰 수 있음
    - 함수를 변수에 저장 가능, 함수를 인자로 다른 함수에 전달 가능, 함수에서 새로운 함수 만들어서 반환 가능
  - 불변성(immutability) 
    - 일단 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용해 프로그램 작성
  - 부수 효과(side effect) 없음
    - 순수 함수 사용 
    > 순수 함수: 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 다른 바깥 환경과 상호작용하지 않는 함수
- 함수형 프로그래밍의 장점
  - 간결성 
  - 다중 스레드를 사용해도 안전함
  - 테스트하기 쉬움 (준비 코드 없이 독립적으로 테스트 가능)

### 1.2.4 무료 오픈소스
- 코틀린과 관련된 모든 도구는 오픈소스로, 어떤 목적에든 무료로 사용 가능

<br>
<br>

## 1.3 코틀린 응용

### 1.3.1 코틀린 서버 프로그래밍
- 자바 코드와 매끄럽게 상호운용 가능하다는 큰 장점을 가짐
- 새로운 컴포넌트를 작성하거나 기존 서비스 코드를 코틀린으로 이식해야 하는 경우 모두 잘 들어맞음
- 자바 클래스를 코틀린으로 확장해도 아무 문제가 없으며, 코틀린 클래스 안의 메소드나 필드에 특정 애노테이션을 붙여야 하는 경우에도 아무 문제가 없음

### 1.3.2 코틀린 안드로이드 프로그래밍
> 생략

<br>
<br>

## 1.4 코틀린의 철학

### 1.4.1 실용성
- 코틀린은 실제 문제를 해결하기 위해 만들어진 실용적인 언어
- 연구를 위한 언어가 아님
- 어느 특정 프로그래밍 스타일이나 패러다임을 사용할 것을 강제하지 않음
- 도구를 강조함

### 1.4.2 간결성
- 코틀린을 만들면서 프로그래머가 작성하는 코드에서 의미가 없는 부분을 줄이고, 언어가 요구하는 구조를 만족시키기 위해 별 뜻은 없지만 프로그램에 꼭 넣어야 하는 부수적인 요소를 줄이기 위해 많은 노력을 기울였음
- `getter`, `setter`, 생성자 파라미터를 필드에 대입하기 위한 로직 등 자바에 존재하는 준비코드를 묵시적으로 제공
- 반복되거나 길어질 수 있는 코드를 라이브러리 함수 호출로 대치 가능

### 1.4.3 안전성
- 코틀린을 JVM에서 실행한다는 사실 자체로 상당한 안전성 보장 (메모리 안전성 보장, 버퍼 오버플로 방지, 동적 메모리 할당 관련 문제 예방)
- 실행 시점에 오류를 발생시키는 대신, 컴파일 시점 검사를 통해 오류를 더 많이 방지해줌
- 코틀린의 타입 시스템은 null이 될 수 없는 값을 추적
- 실행 시점에 NullPointerException이 발생할 수 있는 연산을 사용하는 코드를 금지함

### 1.4.4 상호운용성
- 기존 자바 라이브러리를 그대로 사용 가능
- 자바 메소드를 호출하거나 자바 클래스를 상속하거나 인터페이스를 구현 하거나 자바 애노테이션을 코틀린 코드에 적용하는 등의 일이 모두 가능
- 코틀린은 자체 컬렉션 라이브러리를 제공하지 않고, 자바 표준 라이브러리 클래스에 의존하여 몇 가지 기능을 더할 뿐

<br>
<br>

## 요약
- 코틀린은 타입 추론을 지원하는 정적 타입 지정 언어
- 코틀린은 객체지향과 함수형 프로그래밍 스타일을 모두 지원
- 코틀린은 서버 애플리케이션, 안드로이드 개발에 잘 활용 가능
- 코틀린은 무료이며 오픈 소스
- 코틀린은 실용적이며 안전하고, 간결하며 상호운용성이 좋음
  - NullPointerException 같이 흔히 발생하는 오류를 방지하고, 읽기 쉽고 간결한 코드를 지원하며, 자바와 아무런 제약 없이 통합 가능

<br>

### Reference
- [Kotlin in Action](http://www.yes24.com/Product/Goods/55148593) - 드미트리 제메로프, 스베트라나 이사코바 저. 에이콘출판사. 2017